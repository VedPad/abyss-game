struct boid{
    float x;
    float y;
    float dirDegrees;
    int id;
    float lookDistance;
    float waterCreatureX;
    float waterCreatureY;
    float realAngle;
    int totalDirectionX;
    int totalDirectionY;
    int averageBoidDirX;
    int averageBoidDirY;
    int averageBoidPosX;
    int averageBoidPosY;
    int doTotalDir;
    int boidCount;
};

struct waterCreature{
    float x;
    float y;
    int dummy1;
    int dummy2;
    int dummy3;
    int dummy4;
    int dummy5;
    int dummy6;
};


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<boid> boidBuffer;
RWStructuredBuffer<waterCreature> creatureBuffer;
int nCreatures;
int nBoids;
int F_TO_I;					// float to int
float I_TO_F;	

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel MainSimulation



[numthreads(32,32,1)]
void MainSimulation (uint3 id : SV_DispatchThreadID)
{
    boid boidNode = boidBuffer[id.x];
    int nodeIndex = id.x;
    int i = id.y;
    float2 totalDirection = float2(0,0);
    float2 averageBoidDir = float2(0,0);
    float2 averageBoidPos = float2(0,0);
    boid otherBoidNode = boidBuffer[id.y];
    if(i != nodeIndex){
             float magnitude = distance(float2(otherBoidNode.x, otherBoidNode.y), float2(boidNode.x, boidNode.y));
            if(magnitude < boidNode.lookDistance){
               
                float2 direction = float2(otherBoidNode.x, otherBoidNode.y) - float2(boidNode.x, boidNode.y);
                float2 temp = direction/magnitude;
                InterlockedAdd(boidBuffer[nodeIndex].totalDirectionX, (int)(temp.x * F_TO_I));
                InterlockedAdd(boidBuffer[nodeIndex].totalDirectionY, (int)(temp.y * F_TO_I));
                if(otherBoidNode.id == boidNode.id){
                     InterlockedAdd(boidBuffer[nodeIndex].averageBoidDirX, (int)(cos(otherBoidNode.realAngle) * F_TO_I));
                     InterlockedAdd(boidBuffer[nodeIndex].averageBoidDirY, (int)(sin(otherBoidNode.realAngle) * F_TO_I));
                     InterlockedAdd(boidBuffer[nodeIndex].averageBoidPosX, (int)(cos(otherBoidNode.x) * F_TO_I));
                     InterlockedAdd(boidBuffer[nodeIndex].averageBoidPosY, (int)(cos(otherBoidNode.y) * F_TO_I));
                }
                boidBuffer[nodeIndex].doTotalDir = 1;
                InterlockedAdd(boidBuffer[nodeIndex].boidCount, 1);
            }
     }
   
   /* while(i < nBoids){
        if(i == nodeIndex){
            i++;
            continue;
        }
        boid otherBoidNode = boidBuffer[i];
        float magnitude = distance(float2(otherBoidNode.x, otherBoidNode.y), float2(boidNode.x, boidNode.y));
        if(magnitude < boidNode.lookDistance){
             float2 direction = float2(otherBoidNode.x, otherBoidNode.y) - float2(boidNode.x, boidNode.y);
                totalDirection += direction/magnitude;
                if(otherBoidNode.id == boidNode.id){
                    averageBoidDir +=  float2(cos(otherBoidNode.realAngle), sin(otherBoidNode.realAngle));;
                     averageBoidPos += float2(otherBoidNode.x, otherBoidNode.y);
                }
                 
                doTotalDir = true;
                boidsNearby += 1;
        
        }
       
        i++;
    }*/
    /*if(doTotalDir){
        averageBoidPos = averageBoidPos/boidsNearby;
        float2 dir = averageBoidPos - float2(boidNode.x, boidNode.y);
        float mag = distance(float2(0,0), dir);
        averageBoidPos = dir/mag;
        boidBuffer[nodeIndex].debug1 = averageBoidPos.x;
        boidBuffer[nodeIndex].debug2 = averageBoidPos.y;
        averageBoidDir = averageBoidDir/boidsNearby;
        totalDirection = -totalDirection/boidsNearby;
        totalDirection += averageBoidDir;
        totalDirection += averageBoidPos;
        totalDirection = totalDirection/3;
        float angle = atan2(totalDirection.y, totalDirection.x);
       
        boidBuffer[nodeIndex].dirDegrees = angle;
    }*/
    
    
}

#pragma kernel DoWaterCreatureAvoidance



[numthreads(32,1,1)]
void DoWaterCreatureAvoidance (uint3 id : SV_DispatchThreadID){
    boid boidNode = boidBuffer[id.x];
    int nodeIndex = id.x;
    int i = 0;
    while(i < nCreatures){
        waterCreature creature = creatureBuffer[i];
        float2 otherPos = float2(creature.x, creature.y);
        float2 direction = otherPos - float2(boidNode.x, boidNode.y);
        float mag = distance(float2(0,0), direction);
        if(mag <= boidNode.lookDistance){
            float2 temp = direction/mag;
            boidBuffer[nodeIndex].waterCreatureX += temp.x;
            boidBuffer[nodeIndex].waterCreatureY += temp.y;
        }
        i++;
    }
}

#pragma kernel DoBoidChanges

[numthreads(32,1,1)]
void DoBoidChanges (uint3 id : SV_DispatchThreadID)
{
    boid boid = boidBuffer[id.x];
    int nodeIndex = id.x;
    if(boid.doTotalDir == 1){
        float2 averageBoidPos = float2((float)boid.averageBoidPosX * I_TO_F, (float)boid.averageBoidPosY * I_TO_F);
        averageBoidPos = averageBoidPos/boid.boidCount;
        float2 dir = averageBoidPos - float2(boid.x, boid.y);
        float mag = distance(float2(0,0), dir);
        averageBoidPos = dir/mag;
        float2 averageBoidDir = float2((float)boid.averageBoidDirX * I_TO_F, (float)boid.averageBoidDirY * I_TO_F);
        averageBoidDir = averageBoidDir/boid.boidCount;
        float2 totalDirection = float2((float)boid.totalDirectionX * I_TO_F, (float)boid.totalDirectionY * I_TO_F);
        totalDirection = -totalDirection/boid.boidCount;
        totalDirection += averageBoidDir;
        totalDirection += averageBoidPos;
        float2 waterCreatureVector = float2(boid.waterCreatureX, boid.waterCreatureY);
        totalDirection += -waterCreatureVector/nCreatures * 5;
        totalDirection = totalDirection/4;
         float angle = atan2(totalDirection.y, totalDirection.x);
       
        boidBuffer[nodeIndex].dirDegrees = angle;
    }
}
